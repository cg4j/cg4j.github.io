{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CG4j","text":"<p>Call Graph Generation for Java</p> <p>CG4j is a command-line tool to build call graphs using Class Hierarchy Analysis (CHA) from Java programs and their dependencies.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>This document shows the internal architecture and data flow of cg4j.</p>"},{"location":"architecture/#system-flow","title":"System Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         Input Phase                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n                                \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502   Target JAR File     \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n                                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Analysis Scope Setup                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                \u25bc               \u25bc               \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Primordial   \u2502  \u2502Extension \u2502  \u2502Application \u2502\n        \u2502 (JDK/RT)     \u2502  \u2502 (Deps)   \u2502  \u2502 (Target)   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502               \u2502               \u2502\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Class Hierarchy Analysis (CHA)                     \u2502\n\u2502  \u2022 Builds inheritance tree                                      \u2502\n\u2502  \u2022 Resolves virtual method calls                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Entry Points Generation                       \u2502\n\u2502  \u2022 Find all public methods in Application loader                \u2502\n\u2502  \u2022 Skip Primordial and Extension classes                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     0-CFA Call Graph Build                      \u2502\n\u2502  \u2022 Start from entry points                                      \u2502\n\u2502  \u2022 Use CHA to resolve method calls                              \u2502\n\u2502  \u2022 Iterate until fixpoint (no new edges)                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Edge Extraction (Stream API)                 \u2502\n\u2502  \u2022 Filter fake methods                                          \u2502\n\u2502  \u2022 Normalize boot methods to &lt;boot&gt;                             \u2502\n\u2502  \u2022 Filter RT classes (if includeRt=false)                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      CSV Output                                 \u2502\n\u2502  source_method,target_method                                    \u2502\n\u2502  &lt;boot&gt;,org/slf4j/Logger.info:(...)                            \u2502\n\u2502  org/slf4j/Logger.info:(...),org/slf4j/helpers/...              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#notes","title":"Notes","text":""},{"location":"architecture/#class-loaders","title":"Class Loaders","text":"<ul> <li>Primordial: Java runtime classes (JDK, RT jar) - standard library code</li> <li>Extension: Dependency JARs - external libraries your application uses</li> <li>Application: Target JAR being analyzed - your application code</li> </ul>"},{"location":"architecture/#keywords","title":"Keywords","text":"<ul> <li>RT (Runtime): Java runtime classes from the JDK (java., javax., etc.)</li> <li>: Placeholder for WALA's fake root methods used to bootstrap analysis <li>CHA (Class Hierarchy Analysis): Algorithm that uses inheritance tree to resolve method calls</li> <li>0-CFA: Zero-context-flow-insensitive analysis - fast call graph construction</li> <li>Entry Points: Starting methods for analysis (all public methods in Application loader)</li>"},{"location":"architecture/#wala-fake-methods","title":"WALA Fake Methods","text":"<p>WALA creates artificial methods for analysis bootstrapping: - <code>FakeRootClass.fakeRootMethod</code> - Artificial entry point that calls all real entry points - <code>FakeRootClass.fakeWorldClinit</code> - Artificial class initializer - These are normalized to <code>&lt;boot&gt;</code> in the output for clarity</p>"},{"location":"callgraph-basics/","title":"Call Graph Basics","text":"<p>This document explains the core concepts behind call graph generation in cg4j.</p>"},{"location":"callgraph-basics/#what-is-a-call-graph","title":"What is a Call Graph?","text":"<p>A call graph is a directed graph that represents calling relationships between methods in a program.</p> <ul> <li>Nodes: Methods in your program</li> <li>Edges: Method calls (A \u2192 B means \"method A calls method B\")</li> </ul> <p>Example:</p> <pre><code>main() \u2192 processData()\nprocessData() \u2192 readFile()\nprocessData() \u2192 writeFile()\n</code></pre>"},{"location":"callgraph-basics/#why-are-call-graphs-useful","title":"Why Are Call Graphs Useful?","text":"<ul> <li>Program understanding: Visualize how code flows through your application</li> <li>Impact analysis: Find what breaks when you change a method</li> <li>Security analysis: Trace paths to sensitive operations</li> <li>Dead code detection: Find unreachable methods</li> <li>Testing: Identify test coverage gaps</li> </ul>"},{"location":"callgraph-basics/#call-graph-construction-algorithms","title":"Call Graph Construction Algorithms","text":"<p>cg4j supports two algorithms for resolving virtual method calls: CHA and RTA.</p>"},{"location":"callgraph-basics/#class-hierarchy-analysis-cha","title":"Class Hierarchy Analysis (CHA)","text":"<p>CHA is a fast algorithm that determines which methods might be called at a call site.</p>"},{"location":"callgraph-basics/#the-problem","title":"The Problem","text":"<p>In object-oriented programs, method calls can be dynamic:</p> <pre><code>Animal a = getAnimal(); // Could be Dog, Cat, Bird...\na.speak();              // Which speak() method runs?\n</code></pre>"},{"location":"callgraph-basics/#how-cha-works","title":"How CHA Works","text":"<p>CHA uses the class hierarchy (inheritance tree) to find all possible targets:</p> <ol> <li>Look at the declared type (<code>Animal</code>)</li> <li>Find all subclasses in the hierarchy (<code>Dog</code>, <code>Cat</code>, <code>Bird</code>)</li> <li>Include all implementations of the method (<code>speak()</code>)</li> </ol> <p>Result: Conservative approximation - includes all subtypes in the hierarchy, even if they're never instantiated.</p>"},{"location":"callgraph-basics/#cha-trade-offs","title":"CHA Trade-offs","text":"<p>\u2705 Pros: - Very fast to compute - Simple to understand - Sound (won't miss real calls) - No need to analyze method bodies</p> <p>\u274c Cons: - Over-approximates (includes impossible calls) - Creates edges to methods of classes never instantiated - Less precise than type-sensitive analyses</p>"},{"location":"callgraph-basics/#rapid-type-analysis-rta","title":"Rapid Type Analysis (RTA)","text":"<p>RTA is a more precise algorithm that only considers instantiated types.</p>"},{"location":"callgraph-basics/#how-rta-works","title":"How RTA Works","text":"<p>RTA tracks which classes are actually instantiated (created with <code>new</code>) during analysis:</p> <ol> <li>Start with entry points</li> <li>Track instantiations: Record every <code>new ClassName()</code> encountered</li> <li>Resolve virtual calls: Only consider subtypes that have been instantiated</li> <li>Repeat until no new types are discovered</li> </ol> <p>Result: More precise than CHA - only includes methods of classes that are actually created.</p>"},{"location":"callgraph-basics/#rta-example","title":"RTA Example","text":"<pre><code>public void main() {\n    Animal a = new Dog();\n    a.speak();  // Which speak() methods are possible?\n}\n\nclass Dog extends Animal {\n    public void speak() { bark(); }\n}\n\nclass Cat extends Animal {\n    public void speak() { meow(); }\n}\n\nclass Bird extends Animal {\n    public void speak() { chirp(); }\n}\n</code></pre> <p>CHA result: Includes <code>Dog.speak()</code>, <code>Cat.speak()</code>, <code>Bird.speak()</code> (all subtypes)</p> <p>RTA result: Only includes <code>Dog.speak()</code> (only instantiated type)</p>"},{"location":"callgraph-basics/#rta-trade-offs","title":"RTA Trade-offs","text":"<p>\u2705 Pros: - More precise than CHA - Eliminates impossible calls to never-instantiated classes - Still fast and scalable - Sound (won't miss real calls)</p> <p>\u274c Cons: - Slower than CHA (must analyze method bodies) - Requires tracking instantiation sites - Still over-approximates in some cases</p>"},{"location":"callgraph-basics/#cha-vs-rta-comparison","title":"CHA vs RTA Comparison","text":"Aspect CHA RTA Speed Fastest Fast Precision Lower (all subtypes) Higher (only instantiated) Analysis cost Class hierarchy only Bytecode scanning required Call graph size Larger Smaller Use case Quick overview More accurate analysis"},{"location":"callgraph-basics/#when-to-use-each-algorithm","title":"When to Use Each Algorithm","text":"<p>Use CHA when: - You need fast results - You want maximum soundness (catch everything) - Precision is less important</p> <p>Use RTA when: - You need more accurate call graphs - You want to reduce false positives - Analysis time is acceptable</p>"},{"location":"callgraph-basics/#how-cg4j-uses-cha-and-rta","title":"How cg4j Uses CHA and RTA","text":"<p>cg4j provides two engines with different algorithm support:</p>"},{"location":"callgraph-basics/#wala-engine-default","title":"WALA Engine (Default)","text":"<ul> <li>Uses 0-CFA (Zero Context-Flow-Insensitive Analysis) with CHA</li> <li>More mature and feature-rich</li> <li>Handles complex Java features</li> </ul>"},{"location":"callgraph-basics/#asm-engine","title":"ASM Engine","text":"<ul> <li>Supports both CHA and RTA algorithms</li> <li>Faster and more lightweight</li> <li>Good for straightforward call graph construction</li> </ul> <p>Usage: <pre><code># ASM with CHA (default)\njava -jar cg4j.jar --engine=asm --algorithm=cha app.jar\n\n# ASM with RTA (more precise)\njava -jar cg4j.jar --engine=asm --algorithm=rta app.jar\n\n# WALA (uses 0-CFA with CHA)\njava -jar cg4j.jar --engine=wala app.jar\n</code></pre></p>"},{"location":"callgraph-basics/#worklist-algorithm","title":"Worklist Algorithm","text":"<p>Both CHA and RTA use a worklist-based approach:</p> <ol> <li> <p>Start with entry points (all public methods in cg4j)</p> </li> <li> <p>For each reachable method:</p> </li> <li>Scan method bytecode for call sites</li> <li>Track instantiations (<code>new</code> expressions) - RTA only</li> <li>Resolve virtual calls using CHA or RTA</li> <li> <p>Add discovered methods to worklist</p> </li> <li> <p>Repeat until no new methods are discovered</p> </li> </ol> <p>Key difference: - CHA: Resolves calls to all subtypes in hierarchy - RTA: Resolves calls only to instantiated subtypes</p>"},{"location":"callgraph-basics/#how-cg4j-builds-call-graphs","title":"How cg4j Builds Call Graphs","text":"<ol> <li>Load JAR file and dependencies</li> <li>Find entry points (all public methods)</li> <li>Build class hierarchy from loaded classes</li> <li>Run worklist algorithm:</li> <li>Process each reachable method</li> <li>Extract call sites from bytecode</li> <li>Track instantiations (RTA only)</li> <li>Resolve virtual calls using CHA or RTA</li> <li>Expand the call graph iteratively</li> <li>Output CSV with source \u2192 target edges</li> </ol>"},{"location":"callgraph-basics/#limitations","title":"Limitations","text":""},{"location":"callgraph-basics/#what-cg4j-handles","title":"What cg4j Handles","text":"<p>\u2705 Direct method calls \u2705 Virtual method calls (using CHA) \u2705 Constructor calls \u2705 Static method calls</p>"},{"location":"callgraph-basics/#what-cg4j-may-miss","title":"What cg4j May Miss","text":"<p>\u274c Reflection (<code>Method.invoke()</code>) \u274c Dynamic proxy calls \u274c Lambda expressions (depends on WALA support) \u274c Native methods</p>"},{"location":"callgraph-basics/#key-terminology","title":"Key Terminology","text":"Term Meaning Static call Direct method call, target known at compile-time Virtual call Method call through object reference, resolved at runtime Entry point Starting method for analysis (e.g., <code>main()</code>, public methods) Reachable Method that can be called from an entry point Call site Location in code where a method call occurs Receiver type Type of object on which a method is called"},{"location":"callgraph-basics/#further-reading","title":"Further Reading","text":""},{"location":"callgraph-basics/#foundational-papers","title":"Foundational Papers","text":"<p>CHA (Class Hierarchy Analysis): - Dean, J., Grove, D., and Chambers, C. (1995). Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis. ECOOP'95.   - PDF   - The original paper introducing CHA for call graph construction</p> <p>RTA (Rapid Type Analysis): - Bacon, D. F. and Sweeney, P. F. (1996). Fast Static Analysis of C++ Virtual Function Calls. OOPSLA'96.   - PDF   - Introduces RTA as a more precise alternative to CHA by tracking instantiated types</p>"},{"location":"callgraph-basics/#additional-resources","title":"Additional Resources","text":"<ul> <li>WALA Documentation - Framework used by cg4j</li> <li>Call Graph Construction Algorithms - Comprehensive tutorial on points-to analysis</li> <li>Static Analysis Overview - Course materials on static program analysis</li> </ul>"},{"location":"callgraph-basics/#quick-reference","title":"Quick Reference","text":"What You Want WALA (0-CFA/CHA) ASM with CHA ASM with RTA Fast analysis \u2705 Fast \u2705 Very fast \u2705 Fast More precision \u26a0\ufe0f Moderate \u26a0\ufe0f Lower \u2705 Higher Handle reflection \u274c Limited \u274c No \u274c No Sound results \u2705 Yes \u2705 Yes \u2705 Yes Large programs \u2705 Yes \u2705 Yes \u2705 Yes Smaller call graphs \u26a0\ufe0f Moderate \u274c Larger \u2705 Smaller <p>Recommendation: Start with ASM+RTA for better precision. Use WALA for complex Java features or ASM+CHA for maximum speed.</p>"}]}