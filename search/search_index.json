{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CG4j Call Graph Generation for Java CG4j is a command-line tool to build call graphs using Class Hierarchy Analysis (CHA) from Java programs and their dependencies.","title":"Home"},{"location":"#cg4j","text":"Call Graph Generation for Java CG4j is a command-line tool to build call graphs using Class Hierarchy Analysis (CHA) from Java programs and their dependencies.","title":"CG4j"},{"location":"architecture/","text":"Architecture This document shows the internal architecture and data flow of cg4j. System Flow \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Input Phase \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Target JAR File \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Analysis Scope Setup \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u25bc \u25bc \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Primordial \u2502 \u2502Extension \u2502 \u2502Application \u2502 \u2502 (JDK/RT) \u2502 \u2502 (Deps) \u2502 \u2502 (Target) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Class Hierarchy Analysis (CHA) \u2502 \u2502 \u2022 Builds inheritance tree \u2502 \u2502 \u2022 Resolves virtual method calls \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Entry Points Generation \u2502 \u2502 \u2022 Find all public methods in Application loader \u2502 \u2502 \u2022 Skip Primordial and Extension classes \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 0-CFA Call Graph Build \u2502 \u2502 \u2022 Start from entry points \u2502 \u2502 \u2022 Use CHA to resolve method calls \u2502 \u2502 \u2022 Iterate until fixpoint (no new edges) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Edge Extraction (Stream API) \u2502 \u2502 \u2022 Filter fake methods \u2502 \u2502 \u2022 Normalize boot methods to <boot> \u2502 \u2502 \u2022 Filter RT classes (if includeRt=false) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 CSV Output \u2502 \u2502 source_method,target_method \u2502 \u2502 <boot>,org/slf4j/Logger.info:(...) \u2502 \u2502 org/slf4j/Logger.info:(...),org/slf4j/helpers/... \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Notes Class Loaders Primordial: Java runtime classes (JDK, RT jar) - standard library code Extension: Dependency JARs - external libraries your application uses Application: Target JAR being analyzed - your application code Keywords RT (Runtime): Java runtime classes from the JDK (java. , javax. , etc.) : Placeholder for WALA's fake root methods used to bootstrap analysis CHA (Class Hierarchy Analysis): Algorithm that uses inheritance tree to resolve method calls 0-CFA: Zero-context-flow-insensitive analysis - fast call graph construction Entry Points: Starting methods for analysis (all public methods in Application loader) WALA Fake Methods WALA creates artificial methods for analysis bootstrapping: - FakeRootClass.fakeRootMethod - Artificial entry point that calls all real entry points - FakeRootClass.fakeWorldClinit - Artificial class initializer - These are normalized to <boot> in the output for clarity","title":"Architecture"},{"location":"architecture/#architecture","text":"This document shows the internal architecture and data flow of cg4j.","title":"Architecture"},{"location":"architecture/#system-flow","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Input Phase \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Target JAR File \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Analysis Scope Setup \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u25bc \u25bc \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Primordial \u2502 \u2502Extension \u2502 \u2502Application \u2502 \u2502 (JDK/RT) \u2502 \u2502 (Deps) \u2502 \u2502 (Target) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Class Hierarchy Analysis (CHA) \u2502 \u2502 \u2022 Builds inheritance tree \u2502 \u2502 \u2022 Resolves virtual method calls \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Entry Points Generation \u2502 \u2502 \u2022 Find all public methods in Application loader \u2502 \u2502 \u2022 Skip Primordial and Extension classes \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 0-CFA Call Graph Build \u2502 \u2502 \u2022 Start from entry points \u2502 \u2502 \u2022 Use CHA to resolve method calls \u2502 \u2502 \u2022 Iterate until fixpoint (no new edges) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Edge Extraction (Stream API) \u2502 \u2502 \u2022 Filter fake methods \u2502 \u2502 \u2022 Normalize boot methods to <boot> \u2502 \u2502 \u2022 Filter RT classes (if includeRt=false) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 CSV Output \u2502 \u2502 source_method,target_method \u2502 \u2502 <boot>,org/slf4j/Logger.info:(...) \u2502 \u2502 org/slf4j/Logger.info:(...),org/slf4j/helpers/... \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"System Flow"},{"location":"architecture/#notes","text":"","title":"Notes"},{"location":"architecture/#class-loaders","text":"Primordial: Java runtime classes (JDK, RT jar) - standard library code Extension: Dependency JARs - external libraries your application uses Application: Target JAR being analyzed - your application code","title":"Class Loaders"},{"location":"architecture/#keywords","text":"RT (Runtime): Java runtime classes from the JDK (java. , javax. , etc.) : Placeholder for WALA's fake root methods used to bootstrap analysis CHA (Class Hierarchy Analysis): Algorithm that uses inheritance tree to resolve method calls 0-CFA: Zero-context-flow-insensitive analysis - fast call graph construction Entry Points: Starting methods for analysis (all public methods in Application loader)","title":"Keywords"},{"location":"architecture/#wala-fake-methods","text":"WALA creates artificial methods for analysis bootstrapping: - FakeRootClass.fakeRootMethod - Artificial entry point that calls all real entry points - FakeRootClass.fakeWorldClinit - Artificial class initializer - These are normalized to <boot> in the output for clarity","title":"WALA Fake Methods"},{"location":"callgraph-basics/","text":"Call Graph Basics This document explains the core concepts behind call graph generation in cg4j. What is a Call Graph? A call graph is a directed graph that represents calling relationships between methods in a program. Nodes : Methods in your program Edges : Method calls (A \u2192 B means \"method A calls method B\") Example: main() \u2192 processData() processData() \u2192 readFile() processData() \u2192 writeFile() Why Are Call Graphs Useful? Program understanding : Visualize how code flows through your application Impact analysis : Find what breaks when you change a method Security analysis : Trace paths to sensitive operations Dead code detection : Find unreachable methods Testing : Identify test coverage gaps Call Graph Construction Algorithms cg4j supports two algorithms for resolving virtual method calls: CHA and RTA . Class Hierarchy Analysis (CHA) CHA is a fast algorithm that determines which methods might be called at a call site. The Problem In object-oriented programs, method calls can be dynamic: Animal a = getAnimal(); // Could be Dog, Cat, Bird... a.speak(); // Which speak() method runs? How CHA Works CHA uses the class hierarchy (inheritance tree) to find all possible targets: Look at the declared type ( Animal ) Find all subclasses in the hierarchy ( Dog , Cat , Bird ) Include all implementations of the method ( speak() ) Result : Conservative approximation - includes all subtypes in the hierarchy, even if they're never instantiated. CHA Trade-offs \u2705 Pros: - Very fast to compute - Simple to understand - Sound (won't miss real calls) - No need to analyze method bodies \u274c Cons: - Over-approximates (includes impossible calls) - Creates edges to methods of classes never instantiated - Less precise than type-sensitive analyses Rapid Type Analysis (RTA) RTA is a more precise algorithm that only considers instantiated types . How RTA Works RTA tracks which classes are actually instantiated (created with new ) during analysis: Start with entry points Track instantiations : Record every new ClassName() encountered Resolve virtual calls : Only consider subtypes that have been instantiated Repeat until no new types are discovered Result : More precise than CHA - only includes methods of classes that are actually created. RTA Example public void main() { Animal a = new Dog(); a.speak(); // Which speak() methods are possible? } class Dog extends Animal { public void speak() { bark(); } } class Cat extends Animal { public void speak() { meow(); } } class Bird extends Animal { public void speak() { chirp(); } } CHA result : Includes Dog.speak() , Cat.speak() , Bird.speak() (all subtypes) RTA result : Only includes Dog.speak() (only instantiated type) RTA Trade-offs \u2705 Pros: - More precise than CHA - Eliminates impossible calls to never-instantiated classes - Still fast and scalable - Sound (won't miss real calls) \u274c Cons: - Slower than CHA (must analyze method bodies) - Requires tracking instantiation sites - Still over-approximates in some cases CHA vs RTA Comparison Aspect CHA RTA Speed Fastest Fast Precision Lower (all subtypes) Higher (only instantiated) Analysis cost Class hierarchy only Bytecode scanning required Call graph size Larger Smaller Use case Quick overview More accurate analysis When to Use Each Algorithm Use CHA when: - You need fast results - You want maximum soundness (catch everything) - Precision is less important Use RTA when: - You need more accurate call graphs - You want to reduce false positives - Analysis time is acceptable How cg4j Uses CHA and RTA cg4j provides two engines with different algorithm support: WALA Engine (Default) Uses 0-CFA (Zero Context-Flow-Insensitive Analysis) with CHA More mature and feature-rich Handles complex Java features ASM Engine Supports both CHA and RTA algorithms Faster and more lightweight Good for straightforward call graph construction Usage: # ASM with CHA (default) java -jar cg4j.jar --engine=asm --algorithm=cha app.jar # ASM with RTA (more precise) java -jar cg4j.jar --engine=asm --algorithm=rta app.jar # WALA (uses 0-CFA with CHA) java -jar cg4j.jar --engine=wala app.jar Worklist Algorithm Both CHA and RTA use a worklist-based approach: Start with entry points (all public methods in cg4j) For each reachable method: Scan method bytecode for call sites Track instantiations ( new expressions) - RTA only Resolve virtual calls using CHA or RTA Add discovered methods to worklist Repeat until no new methods are discovered Key difference: - CHA : Resolves calls to all subtypes in hierarchy - RTA : Resolves calls only to instantiated subtypes How cg4j Builds Call Graphs Load JAR file and dependencies Find entry points (all public methods) Build class hierarchy from loaded classes Run worklist algorithm : Process each reachable method Extract call sites from bytecode Track instantiations (RTA only) Resolve virtual calls using CHA or RTA Expand the call graph iteratively Output CSV with source \u2192 target edges Limitations What cg4j Handles \u2705 Direct method calls \u2705 Virtual method calls (using CHA) \u2705 Constructor calls \u2705 Static method calls What cg4j May Miss \u274c Reflection ( Method.invoke() ) \u274c Dynamic proxy calls \u274c Lambda expressions (depends on WALA support) \u274c Native methods Key Terminology Term Meaning Static call Direct method call, target known at compile-time Virtual call Method call through object reference, resolved at runtime Entry point Starting method for analysis (e.g., main() , public methods) Reachable Method that can be called from an entry point Call site Location in code where a method call occurs Receiver type Type of object on which a method is called Further Reading Foundational Papers CHA (Class Hierarchy Analysis): - Dean, J., Grove, D., and Chambers, C. (1995). Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis . ECOOP'95. - PDF - The original paper introducing CHA for call graph construction RTA (Rapid Type Analysis): - Bacon, D. F. and Sweeney, P. F. (1996). Fast Static Analysis of C++ Virtual Function Calls . OOPSLA'96. - PDF - Introduces RTA as a more precise alternative to CHA by tracking instantiated types Additional Resources WALA Documentation - Framework used by cg4j Call Graph Construction Algorithms - Comprehensive tutorial on points-to analysis Static Analysis Overview - Course materials on static program analysis Quick Reference What You Want WALA (0-CFA/CHA) ASM with CHA ASM with RTA Fast analysis \u2705 Fast \u2705 Very fast \u2705 Fast More precision \u26a0\ufe0f Moderate \u26a0\ufe0f Lower \u2705 Higher Handle reflection \u274c Limited \u274c No \u274c No Sound results \u2705 Yes \u2705 Yes \u2705 Yes Large programs \u2705 Yes \u2705 Yes \u2705 Yes Smaller call graphs \u26a0\ufe0f Moderate \u274c Larger \u2705 Smaller Recommendation : Start with ASM+RTA for better precision. Use WALA for complex Java features or ASM+CHA for maximum speed.","title":"Call Graphs Basics"},{"location":"callgraph-basics/#call-graph-basics","text":"This document explains the core concepts behind call graph generation in cg4j.","title":"Call Graph Basics"},{"location":"callgraph-basics/#what-is-a-call-graph","text":"A call graph is a directed graph that represents calling relationships between methods in a program. Nodes : Methods in your program Edges : Method calls (A \u2192 B means \"method A calls method B\") Example: main() \u2192 processData() processData() \u2192 readFile() processData() \u2192 writeFile()","title":"What is a Call Graph?"},{"location":"callgraph-basics/#why-are-call-graphs-useful","text":"Program understanding : Visualize how code flows through your application Impact analysis : Find what breaks when you change a method Security analysis : Trace paths to sensitive operations Dead code detection : Find unreachable methods Testing : Identify test coverage gaps","title":"Why Are Call Graphs Useful?"},{"location":"callgraph-basics/#call-graph-construction-algorithms","text":"cg4j supports two algorithms for resolving virtual method calls: CHA and RTA .","title":"Call Graph Construction Algorithms"},{"location":"callgraph-basics/#class-hierarchy-analysis-cha","text":"CHA is a fast algorithm that determines which methods might be called at a call site.","title":"Class Hierarchy Analysis (CHA)"},{"location":"callgraph-basics/#the-problem","text":"In object-oriented programs, method calls can be dynamic: Animal a = getAnimal(); // Could be Dog, Cat, Bird... a.speak(); // Which speak() method runs?","title":"The Problem"},{"location":"callgraph-basics/#how-cha-works","text":"CHA uses the class hierarchy (inheritance tree) to find all possible targets: Look at the declared type ( Animal ) Find all subclasses in the hierarchy ( Dog , Cat , Bird ) Include all implementations of the method ( speak() ) Result : Conservative approximation - includes all subtypes in the hierarchy, even if they're never instantiated.","title":"How CHA Works"},{"location":"callgraph-basics/#cha-trade-offs","text":"\u2705 Pros: - Very fast to compute - Simple to understand - Sound (won't miss real calls) - No need to analyze method bodies \u274c Cons: - Over-approximates (includes impossible calls) - Creates edges to methods of classes never instantiated - Less precise than type-sensitive analyses","title":"CHA Trade-offs"},{"location":"callgraph-basics/#rapid-type-analysis-rta","text":"RTA is a more precise algorithm that only considers instantiated types .","title":"Rapid Type Analysis (RTA)"},{"location":"callgraph-basics/#how-rta-works","text":"RTA tracks which classes are actually instantiated (created with new ) during analysis: Start with entry points Track instantiations : Record every new ClassName() encountered Resolve virtual calls : Only consider subtypes that have been instantiated Repeat until no new types are discovered Result : More precise than CHA - only includes methods of classes that are actually created.","title":"How RTA Works"},{"location":"callgraph-basics/#rta-example","text":"public void main() { Animal a = new Dog(); a.speak(); // Which speak() methods are possible? } class Dog extends Animal { public void speak() { bark(); } } class Cat extends Animal { public void speak() { meow(); } } class Bird extends Animal { public void speak() { chirp(); } } CHA result : Includes Dog.speak() , Cat.speak() , Bird.speak() (all subtypes) RTA result : Only includes Dog.speak() (only instantiated type)","title":"RTA Example"},{"location":"callgraph-basics/#rta-trade-offs","text":"\u2705 Pros: - More precise than CHA - Eliminates impossible calls to never-instantiated classes - Still fast and scalable - Sound (won't miss real calls) \u274c Cons: - Slower than CHA (must analyze method bodies) - Requires tracking instantiation sites - Still over-approximates in some cases","title":"RTA Trade-offs"},{"location":"callgraph-basics/#cha-vs-rta-comparison","text":"Aspect CHA RTA Speed Fastest Fast Precision Lower (all subtypes) Higher (only instantiated) Analysis cost Class hierarchy only Bytecode scanning required Call graph size Larger Smaller Use case Quick overview More accurate analysis","title":"CHA vs RTA Comparison"},{"location":"callgraph-basics/#when-to-use-each-algorithm","text":"Use CHA when: - You need fast results - You want maximum soundness (catch everything) - Precision is less important Use RTA when: - You need more accurate call graphs - You want to reduce false positives - Analysis time is acceptable","title":"When to Use Each Algorithm"},{"location":"callgraph-basics/#how-cg4j-uses-cha-and-rta","text":"cg4j provides two engines with different algorithm support:","title":"How cg4j Uses CHA and RTA"},{"location":"callgraph-basics/#wala-engine-default","text":"Uses 0-CFA (Zero Context-Flow-Insensitive Analysis) with CHA More mature and feature-rich Handles complex Java features","title":"WALA Engine (Default)"},{"location":"callgraph-basics/#asm-engine","text":"Supports both CHA and RTA algorithms Faster and more lightweight Good for straightforward call graph construction Usage: # ASM with CHA (default) java -jar cg4j.jar --engine=asm --algorithm=cha app.jar # ASM with RTA (more precise) java -jar cg4j.jar --engine=asm --algorithm=rta app.jar # WALA (uses 0-CFA with CHA) java -jar cg4j.jar --engine=wala app.jar","title":"ASM Engine"},{"location":"callgraph-basics/#worklist-algorithm","text":"Both CHA and RTA use a worklist-based approach: Start with entry points (all public methods in cg4j) For each reachable method: Scan method bytecode for call sites Track instantiations ( new expressions) - RTA only Resolve virtual calls using CHA or RTA Add discovered methods to worklist Repeat until no new methods are discovered Key difference: - CHA : Resolves calls to all subtypes in hierarchy - RTA : Resolves calls only to instantiated subtypes","title":"Worklist Algorithm"},{"location":"callgraph-basics/#how-cg4j-builds-call-graphs","text":"Load JAR file and dependencies Find entry points (all public methods) Build class hierarchy from loaded classes Run worklist algorithm : Process each reachable method Extract call sites from bytecode Track instantiations (RTA only) Resolve virtual calls using CHA or RTA Expand the call graph iteratively Output CSV with source \u2192 target edges","title":"How cg4j Builds Call Graphs"},{"location":"callgraph-basics/#limitations","text":"","title":"Limitations"},{"location":"callgraph-basics/#what-cg4j-handles","text":"\u2705 Direct method calls \u2705 Virtual method calls (using CHA) \u2705 Constructor calls \u2705 Static method calls","title":"What cg4j Handles"},{"location":"callgraph-basics/#what-cg4j-may-miss","text":"\u274c Reflection ( Method.invoke() ) \u274c Dynamic proxy calls \u274c Lambda expressions (depends on WALA support) \u274c Native methods","title":"What cg4j May Miss"},{"location":"callgraph-basics/#key-terminology","text":"Term Meaning Static call Direct method call, target known at compile-time Virtual call Method call through object reference, resolved at runtime Entry point Starting method for analysis (e.g., main() , public methods) Reachable Method that can be called from an entry point Call site Location in code where a method call occurs Receiver type Type of object on which a method is called","title":"Key Terminology"},{"location":"callgraph-basics/#further-reading","text":"","title":"Further Reading"},{"location":"callgraph-basics/#foundational-papers","text":"CHA (Class Hierarchy Analysis): - Dean, J., Grove, D., and Chambers, C. (1995). Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis . ECOOP'95. - PDF - The original paper introducing CHA for call graph construction RTA (Rapid Type Analysis): - Bacon, D. F. and Sweeney, P. F. (1996). Fast Static Analysis of C++ Virtual Function Calls . OOPSLA'96. - PDF - Introduces RTA as a more precise alternative to CHA by tracking instantiated types","title":"Foundational Papers"},{"location":"callgraph-basics/#additional-resources","text":"WALA Documentation - Framework used by cg4j Call Graph Construction Algorithms - Comprehensive tutorial on points-to analysis Static Analysis Overview - Course materials on static program analysis","title":"Additional Resources"},{"location":"callgraph-basics/#quick-reference","text":"What You Want WALA (0-CFA/CHA) ASM with CHA ASM with RTA Fast analysis \u2705 Fast \u2705 Very fast \u2705 Fast More precision \u26a0\ufe0f Moderate \u26a0\ufe0f Lower \u2705 Higher Handle reflection \u274c Limited \u274c No \u274c No Sound results \u2705 Yes \u2705 Yes \u2705 Yes Large programs \u2705 Yes \u2705 Yes \u2705 Yes Smaller call graphs \u26a0\ufe0f Moderate \u274c Larger \u2705 Smaller Recommendation : Start with ASM+RTA for better precision. Use WALA for complex Java features or ASM+CHA for maximum speed.","title":"Quick Reference"}]}